# 1.4 클로저

> ### You will learn 🤔
>- 1.4.1 클로저의 정의
>- 1.4.2 변수의 유효 범위, 스코프
>- 1.4.3 클로저의 활용
>- 1.4.4 주의할 점

---

### Q1. 클로저(closure)와 일반 함수의 차이점은 무엇인가요? (경민)
- 선언된 환경을 기억한다는 차이가 있습니다. 클로저가 선언되면 당시의 환경을 기억하기 위해 해당 함수가 실행되고 있지 않을 때에도 항상 메모리를 점유하게 됩니다.

### Q2. setState 함수가 useState로 생성된 상태 변수의 최신 값을 어떻게 확인할 수 있는지 설명해주세요. (주희)
- useState 내부에서 setState가 선언된 클로저이고, setState가 useState내의 변수를 클로저로 기억하고 있어서

### Q3. 클로저가 메모리 사용에 부담을 주는 이유를 가비지 컬렉션 관점에서 설명해주세요. (승훈)
- 더이상 사용하지 않는 것을 메모리에서 해제하는데, 클로저는 렉시컬 환경을 기억해야 하기 때문에 gc 대상이 되지 않아서 메모리 사용에 부담을 주게 됩니다.

### Q4. 아래 코드의 결과를 설명하고, 스코프를 이용해 1초 간격으로 0부터 4까지 출력되도록 수정해주세요. (채림)
```javascript
for (var i = 0; i < 5; i++){
  setTimeout(function(){
    console.log(i);
  }, i * 1000);
}
```
- 현재 코드를 실행하면 5가 5번 출력된다.
- 1) i를 선언할 때 let을 사용한다.
     - let은 블록 레벨 스코프를 사용한다.
- 2) 클로저를 사용하려면, setTimeout 안의 function을 즉시실행함수로 변경
     - 즉실함은 함수가 선언되고 바로 실행되는데, 총 5번 선언/실행되며 각각 다른 클로저를 갖게 되기 때문

### Q5. 아래 코드에서 클로저가 생성되고, 메모리에 올라가는 시점에 대해서 설명해주세요. (도영)
``` javascript
function outer() {
  let outerVar = 'outer';

  function inner() {
    console.log(outerVar);
  }

  return inner;
}

const closureFunc = outer(); --> 여기에서 메모리에 올라간다.

```
- outer가 실행되면 inner가 정의되고 outer를 호출하면 inner가 반환됨
- 호출 시점에 반환될 때 클로저를 생성하면서 메모리에 올라간다.
- 실행 시점에 생성되어 메모리에 올라간다.
