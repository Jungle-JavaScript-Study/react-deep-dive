# 3.1 리액트의 모든 훅 파헤치기

> ### You will learn 📝
>- 3.1.1 useState
>- 3.1.2 useEffect
>- 3.1.3 useMemo
>- 3.1.4 useCallback
>- 3.1.5 useRef
>- 3.1.6 useContext
>- 3.1.7 useReducer
>- 3.1.8 useImperativeHandle
>- 3.1.9 useLayoutEffect
>- 3.1.10 useDebugValue
>- 3.1.11 훅의 규칙

---

### Q1. 게으른 초기화란 무엇이고, 어떤 상황에 사용하면 좋을까요? (경민)
- useState 초기값에 비용이 드는 로직이 필요하다면, 한 번만 계산하게 해주는 방법
- 사용법) useState 초기값이 복잡한 계산이 요구되는 함수일 경우, 함수 자체를 넣어주면 된다.
- 초기화 함수 내부 로직이 => '로컬 스토리지, 세션 스토리지, map, filter, find 등 배열 메서드 등' 실행 비용이 많이 드는 경우에 사용하면 좋다.

### Q2. useEffect 인수로 비동기 함수를 바로 쓰지 않는 이유는? (민규)
- 경쟁 조건을 피하기 위한 것
- useEffect의 인수로 비동기 함수를 받고 그 안에서 상태를 바꾸는 동작을 한다면, 비동기 함수가 실행이 완료되고 상태가 변경되었을 때 다시 리렌더가 일어나는 흐름일텐데
- 그 사이에 다른 동작으로 인해 상태가 변경되어 리렌더가 일어나면 이전 비동기 함수의 완료가 보장되지 않은 상태에서 호출된 것이므로 순서가 보장되지 않는 문제가 있다.
- useEffect의 클린업 함수도 실행 시점이 특정 useEffect가 재실행될 때 직전 useEffect에서 정의된 cleanup이 실행되는 것인데, 비동기로 동작하게 되면 순서가 꼬일 수 있다.
👏

### Q3. useEffect 훅의 의존성 배열로 아무런 값도 넘겨주지 않는다면 어떻게 동작하는지 설명해주세요.(도영)
- 매 리렌더마다 재실행되고, 클라이언트 사이드에서만 실행된다.

### Q4. useEffect의 클린업 함수와 생명주기 메서드인 unmount의 차이는? (주희)
- unmount는 리액트의 라이프사이클 관점에서 컴포넌트가 DOM에서 사라지는 것
- 클린업 함수는 이전에 실행한 값을 기반으로 부수효과를 취소하는 개념
- 클린업 함수는 함수 컴포넌트가 리렌더링됐을 때 의존성 변화가 있었을 당시 이전의 값을 기준으로 실행되는, 이전 상태를 청소해 주는 개념이다.

### Q5. `useState`는 컴포넌트 내에서만 선언할 수 있습니다. 컴포넌트는 매번 렌더링될 때마다 실행되는데, state가 매번 초기값으로 재설정되지 않고 이전 값을 유지할 수 있는 원리는 무엇일까요? (채림)
- 클로저를 사용해서 함수 내부의 함수가 지역변수인 state를 참조할 수 있기 때문
- setState는 함수를 리턴하는 함수일 것이다.
