# 2.5 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션

> ### You will learn 📝
>- 2.5.1 주장 1: 섣부른 최적화는 독이다, 꼭 필요한 곳에만 메모이제이션을 추가하자
>- 2.5.2 주장 2: 렌더링 과정의 비용은 비싸다, 모조리 메모이제이션해 버리자

---

### Q1. useMemo와 useCallback을 사용해서 메모이제이션 하는 것이 권장되는 상황은 언제인가요? (주희)

### Q2. 다음 코드에서 예상되는 동작과 문제점을 설명하고 해결책을 제안해주세요. (경민)

```javascript
// useState와 useEffect는 import 했습니다.

function useInvest(number: number) {
    const [seedMoney, setSeedMoney] = useState(0);
    const [debt, setDebt] = useState(0);

    useEffect(() => {
        setSeedMoney(number - 1000);
        setDebt(number * 2);
    }, [number]);

    return { seedMoney, debt }
}

export default function App() {
    const [counter, setCounter] = useState(0);
    
    const yourAccount = useInvest(10000);

    useEffect(() => {
        console.log(yourAccount.seedMoney, yourAccount.debt);
    }, [yourAccount])

    function handleClick() {
        setCounter((prev) => prev + 1);
    }

    return (
        <>
            <h1>{counter}</h1>
            <button onClick={handleClick}>+</button>
        </>

    )
}
```

### Q3. useMemo로 모조리 캐싱하면 좋지 않을까요? 하지않는다면 이유가뭐고 언제 사용할까요?(민규)